// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{NOTE_COMMITMENT_ELF, SPEND_PROOF_ELF};
use risc0_zkvm::{default_prover, ExecutorEnv};
use tracing_subscriber::{fmt, EnvFilter};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    fmt().with_env_filter(EnvFilter::from_default_env()).init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // Example note data
    let note_data = b"Hello, RISC Zero!".to_vec();
    
    // Create execution environment for note commitment
    let env = ExecutorEnv::builder()
        .write(&note_data)
        .unwrap()
        .build()
        .unwrap();
    
    // Execute the note commitment program
    let prover = default_prover();
    let receipt = prover.prove(env, NOTE_COMMITMENT_ELF).unwrap();
    
    // Get the commitment from the receipt
    let commitment: [u8; 32] = receipt.receipt.journal.decode().unwrap();
    
    println!("Note commitment: {:?}", commitment);

    // Create spend input
    let spend_input = SpendInput {
        note_data: note_data.clone(),
        note_commitment: commitment.to_vec(),
        public_key: vec![0; 32], // Example public key
        signature: vec![0; 64],  // Example signature
        amount: 100,         // Example amount
        spend_amount: 50,    // Example spend amount
    };

    // Create execution environment for spend proof
    let env = ExecutorEnv::builder()
        .write(&spend_input)
        .unwrap()
        .build()
        .unwrap();
    
    // Execute the spend proof program
    let receipt = prover.prove(env, SPEND_PROOF_ELF).unwrap();
    
    // Get the new commitment from the receipt
    let new_commitment: Vec<u8> = receipt.receipt.journal.decode().unwrap();
    
    println!("New note commitment: {:?}", new_commitment);
}

#[derive(serde::Serialize, serde::Deserialize)]
struct SpendInput {
    note_data: Vec<u8>,
    note_commitment: Vec<u8>,
    public_key: Vec<u8>,
    signature: Vec<u8>,
    amount: u64,
    spend_amount: u64,
}
