// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{NOTE_COMMITMENT_ELF, NOTE_COMMITMENT_ID, SPEND_PROOF_ELF, SPEND_PROOF_ID };
use risc0_zkvm::{
    default_prover, 
    ExecutorEnv,
};
use tracing_subscriber::{fmt, EnvFilter};
use std::fs::File;
use serde::{Serialize, Deserialize};
use bytemuck::cast_slice;
use clap::Parser;
use bincode;
use sha2::{Sha256, Digest};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[arg(long = "proof", value_name = "PROOF_TYPE")]
    proof_type: String,
    
    #[arg(long = "amount", value_name = "AMOUNT")]
    amount: Option<u64>,
}

#[derive(Serialize, Deserialize)]
struct VerificationInput {
    receipt_path: String,
    journal: Vec<u8>,
    image_id: Vec<u8>,
}

#[derive(Serialize, Deserialize)]
struct NoteData {
    amount: u64,
    data: Vec<u8>,
}

#[derive(Serialize, Deserialize)]
struct SpendInput {
    note_data: Vec<u8>,
    note_commitment: [u8; 32],
    public_key: Vec<u8>,
    signature: Vec<u8>,
    amount: u64,
    spend_amount: u64,
}

fn compute_note_commitment(note_data: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(note_data);
    let result = hasher.finalize();
    result.into()
}

fn save_verification_input(receipt_path: &str, journal: &[u8], image_id: &[u8]) {
    let input = VerificationInput {
        receipt_path: receipt_path.to_string(),
        journal: journal.to_vec(),
        image_id: image_id.to_vec(),
    };
    
    let file = File::create("verification_input.json").expect("Failed to create verification input file");
    serde_json::to_writer_pretty(file, &input).expect("Failed to write verification input");
}

fn save_receipt(receipt_path: &str, receipt: &risc0_zkvm::Receipt) {
    let mut file = File::create(receipt_path).expect("Failed to create receipt file");
    ciborium::ser::into_writer(receipt, &mut file).expect("Failed to write receipt");
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    fmt().with_env_filter(EnvFilter::from_default_env()).init();

    let cli = Cli::parse();
    let prover = default_prover();

    match cli.proof_type.as_str() {
        "note-commitment" => {
            let amount = cli.amount.expect("Amount is required for note-commitment proof");
            
            // Create note data with the specified amount
            let note_data = NoteData {
                amount,
                data: b"Hello, RISC Zero!".to_vec(),
            };
            
            // Serialize note data
            let serialized_note = bincode::serialize(&note_data)
                .expect("Failed to serialize note data");
            
            // Create execution environment with both note data and amount
            let env = ExecutorEnv::builder()
                .write(&serialized_note)
                .unwrap()
                .write(&amount)
                .unwrap()
                .build()
                .unwrap();
            
            // Execute the note commitment program
            let receipt = prover.prove(env, NOTE_COMMITMENT_ELF).unwrap();
            
            // Get the commitment from the receipt
            let commitment: [u8; 32] = receipt.receipt.journal.decode().unwrap();
            
            println!("Note commitment: {:?}", commitment);

            // Save note commitment receipt
            let receipt_path = "note_commitment_receipt.cbor";
            save_receipt(receipt_path, &receipt.receipt);
            
            println!("Note Commitment Image Id {:?}", risc0_zkvm::Digest::new(NOTE_COMMITMENT_ID));
            save_verification_input(
                receipt_path,
                &receipt.receipt.journal.bytes,
                cast_slice(&NOTE_COMMITMENT_ID),
            );
        }
        "spend" => {
            // Create note data with proper structure
            let note_data = NoteData {
                amount: 100,  // Example amount
                data: b"Hello, RISC Zero!".to_vec(),
            };
            
            // Serialize note data
            let serialized_note = bincode::serialize(&note_data)
                .expect("Failed to serialize note data");
            
            // Compute the commitment for the note data
            let commitment = compute_note_commitment(&serialized_note);
            
            // In a real production system, the set of valid commitments would be represented by a Merkle tree (commitment tree)
            // whose root is maintained on-chain. To prove a note is spendable, you would:
            // 1. Sync the latest Merkle root (commitment tree root) from the blockchain.
            // 2. Provide a Merkle proof (authentication path) showing that this note's commitment is included in the tree.
            // 3. Pass the Merkle root and proof as inputs to the guest program (ZK circuit).
            // 4. The guest program would verify that the note commitment is indeed part of the tree using the proof and root.
            //
            // In this demo, we simply use a vector of valid commitments for illustration.
            // In production, replace this with Merkle root and proof logic.
            let valid_commitments = vec![commitment];

            // For demo purposes, create a simple signature
            let public_key = b"public_key".to_vec();
            let message = [commitment.as_slice(), note_data.amount.to_le_bytes().as_slice()].concat();
            let mut hasher = Sha256::new();
            hasher.update(&public_key);
            hasher.update(&message);
            let signature = hasher.finalize().to_vec();

            let spend_input = SpendInput {
                note_data: serialized_note,
                note_commitment: commitment,
                public_key,
                signature,
                amount: note_data.amount,
                spend_amount: 50,    // Example spend amount
            };

            // Create execution environment for spend proof
            let env = ExecutorEnv::builder()
                .write(&spend_input)
                .unwrap()
                .write(&valid_commitments)
                .unwrap()
                .build()
                .unwrap();
            
            // Execute the spend proof program
            let receipt = prover.prove(env, SPEND_PROOF_ELF).unwrap();
            
            // Get the new commitment from the receipt
            let new_commitment: [u8; 32] = receipt.receipt.journal.decode().unwrap();
            
            println!("New note commitment: {:?}", new_commitment);

            // Save spend proof receipt
            let receipt_path = "spend_proof_receipt.cbor";
            save_receipt(receipt_path, &receipt.receipt);
            
            // Save verification input
            println!("Saving journal: {:?}", new_commitment);
            println!("Spren Proof Image Id {:?}", risc0_zkvm::Digest::new(SPEND_PROOF_ID));
            save_verification_input(
                receipt_path,
                &receipt.receipt.journal.bytes,
                cast_slice(&SPEND_PROOF_ID),
            );
        }
        _ => {
            eprintln!("Unknown proof type: {}", cli.proof_type);
            eprintln!("Usage: cargo run -- --proof [note-commitment|spend] --amount <AMOUNT>");
            std::process::exit(1);
        }
    }
}

