// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{NOTE_COMMITMENT_ELF, NOTE_COMMITMENT_ID, SPEND_PROOF_ELF, SPEND_PROOF_ID };
use risc0_zkvm::{default_prover, ExecutorEnv};
use tracing_subscriber::{fmt, EnvFilter};
use std::fs::File;
use serde::{Serialize, Deserialize};
use bytemuck::cast_slice;
use clap::Parser;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[arg(long = "proof", value_name = "PROOF_TYPE")]
    proof_type: String,
}

#[derive(Serialize, Deserialize)]
struct VerificationInput {
    receipt_path: String,
    journal: Vec<u8>,
    image_id: Vec<u8>,
}

#[derive(Serialize, Deserialize)]
struct ReceiptData {
    journal: Vec<u8>,
    seal: Vec<u8>,
}

fn save_verification_input(receipt_path: &str, journal: &[u8], image_id: &[u8]) {
    let input = VerificationInput {
        receipt_path: receipt_path.to_string(),
        journal: journal.to_vec(),
        image_id: image_id.to_vec(),
    };
    
    let file = File::create("verification_input.json").expect("Failed to create verification input file");
    serde_json::to_writer_pretty(file, &input).expect("Failed to write verification input");
}

fn save_receipt(receipt_path: &str, receipt: &risc0_zkvm::Receipt) {
    let mut file = File::create(receipt_path).expect("Failed to create receipt file");
    ciborium::ser::into_writer(receipt, &mut file).expect("Failed to write receipt");
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    fmt().with_env_filter(EnvFilter::from_default_env()).init();

    let cli = Cli::parse();
    let prover = default_prover();

    match cli.proof_type.as_str() {
        "note-commitment" => {
            // Example note data
            let note_data = b"Hello, RISC Zero!".to_vec();
            
            // Create execution environment for note commitment
            let env = ExecutorEnv::builder()
                .write(&note_data)
                .unwrap()
                .build()
                .unwrap();
            
            // Execute the note commitment program
            let receipt = prover.prove(env, NOTE_COMMITMENT_ELF).unwrap();
            
            // Get the commitment from the receipt
            let commitment: [u8; 32] = receipt.receipt.journal.decode().unwrap();
            
            println!("Note commitment: {:?}", commitment);

            // Save note commitment receipt
            let receipt_path = "note_commitment_receipt.cbor";
            save_receipt(receipt_path, &receipt.receipt);
            
            save_verification_input(
                receipt_path,
                &receipt.receipt.journal.bytes,
                cast_slice(&NOTE_COMMITMENT_ID),
            );
        }
        "spend" => {
            // Example note data
            let note_data = vec![0u8; 32];

            // Normally, you'd load the real commitment from somewhere
            let commitment = vec![0u8; 32]; // Placeholder, replace with real value if needed

            let spend_input = SpendInput {
                note_data: note_data.clone(),
                note_commitment: commitment.clone(),
                public_key: vec![0; 32], // Example public key
                signature: vec![0; 64],  // Example signature
                amount: 100,         // Example amount
                spend_amount: 50,    // Example spend amount
            };

            // Create execution environment for spend proof
            let env = ExecutorEnv::builder()
                .write(&spend_input)
                .unwrap()
                .build()
                .unwrap();
            
            // Execute the spend proof program
            let receipt = prover.prove(env, SPEND_PROOF_ELF).unwrap();
            
            // Get the new commitment from the receipt
            let new_commitment: Vec<u8> = receipt.receipt.journal.decode().unwrap();
            
            println!("New note commitment: {:?}", new_commitment);

            // Save spend proof receipt
            let receipt_path = "spend_proof_receipt.cbor";
            save_receipt(receipt_path, &receipt.receipt);
            
            // Save verification input
            println!("Saving journal: {:?}", new_commitment);
            save_verification_input(
                receipt_path,
                &receipt.receipt.journal.bytes,
                cast_slice(&SPEND_PROOF_ID),
            );
        }
        _ => {
            eprintln!("Unknown proof type: {}", cli.proof_type);
            eprintln!("Usage: cargo run -- --proof [note-commitment|spend]");
            std::process::exit(1);
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
struct SpendInput {
    note_data: Vec<u8>,
    note_commitment: Vec<u8>,
    public_key: Vec<u8>,
    signature: Vec<u8>,
    amount: u64,
    spend_amount: u64,
}

